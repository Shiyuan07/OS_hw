## 思考题

### 启动顺序

1. 段寄存器的字段含义和功能有哪些？
		* Base: 段的起始地址
		* Limit:　段的大小 
		* Attribute:　权限等属性 
		* Selector:　用于索引段表，进行逻辑－线性地址转换

2. 描述符特权级DPL、当前特权级CPL和请求特权级RPL的含义是什么？在哪些寄存器中存在这些字段？对应的访问条件是什么？
	* DPL：描述符特权级，用来实现保护机制，规定访问该段的权限级别。保存在段描述符中的权限位。
	* CPL：当前特权级，定义了当前所执行程序的特权级别，存在于cs寄存器的低两位。
	* RPL，请求特权级，说明的是进程对段访问的请求权限，保存在段寄存器的Selector的最低两位。
3. 分析可执行文件格式elf的格式（无需回答）

### 4.2 C函数调用的实现

### 4.4 x86中断处理过程

1. 中断处理中硬件压栈内容？用户态中断和内核态中断的硬件压栈有什么不同？
	* 硬件将eflags、cs、eip、err code依次压栈
	* 用户态涉及特权级切换，需要额外将ss和esp压栈，内核态中断不需要。
2. 为什么在用户态的中断响应要使用内核堆栈？
	* 为了防止用户修改内核程序
3. trap类型的中断门与interrupt类型的中断门有啥设置上的差别？如果在设置中断门上不做区分，会有什么可能的后果?
	* interrupt类型的中断门被调用时，中断会被CPU自动禁止；而trap类型的中断门被调用时，CPU则不会去禁止或打开中断，而是保留它原来的样子。若都禁止，则系统调用无法及时得到响应。若都不禁止，则可能会出现中断重复触发，嵌套过多的问题

### 4.8 练习四和五 ucore内核映像加载和函数调用栈分析

1. 在kdebug.c文件中用到的函数`read_ebp`是内联的，而函数`read_eip`不是内联的。为什么要设计成这样？
	* 因为寄存器ebp的值可以访问，eip的值无法直接访问。

### 4.9 练习六 完善中断初始化和处理

1. CPU加电初始化后中断是使能的吗？为什么？
	* 不能。因为最初加电只是初始化一些寄存器，OS没有启动，IDT也没有建立，因此不是使能的。